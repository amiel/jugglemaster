/*
 * JMLib - Portable JuggleMaster Library
 * Version 2.0
 * (C) Per Johan Groland 2000-2006, Gary Briggs 2003
 *
 * Based on JuggleMaster Version 1.60
 * Copyright (c) 1995-1996 Ken Matsuoka
 *
 * You may redistribute and/or modify JMLib under the terms of the
 * Modified BSD License as published in various places online or in the
 * COPYING.jmlib file in the package you downloaded.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT  ANY  WARRANTY;  without   even  the  implied  warranty  of
 * MERCHANTABILITY or  FITNESS FOR A PARTICULAR PURPOSE.   See the
 * Modified BSD License for more details.
 */ 

#include <stdio.h>
#include "../../jmlib/patterns.h"
#include "../../jmlib/validator.h"

void writeHeader(FILE* f);
void writeStyles(FILE* f);
void writePatterns(FILE* f);
void writeFooter(FILE* f);

// To run from Debug folder
//const char* infile =  "../../../../data/patterns.jm";
//const char* outfile = "../patterns.js";
//
const char* infile =  "../../../data/patterns.jm";
const char* outfile = "patterns.js";

struct groups_t groups;
struct styles_t styles;

struct pattern_group_t* current_group;
struct style_t* current_style;
struct pattern_t* current_pattern;

int main(int argc, char* argv[]) {
  FILE* in = fopen(infile, "r");

  if (!in) {
    printf("Error: Failed opening input file\n");
    return false;
  }

  FILE* out = fopen(outfile, "w");

  if (!out) {
    printf("Error: Failed opening output file\n");
    fclose(in);
    return false;
  }

  if (!ParsePatterns(in, &groups, &styles)) {
    printf("Error: Pattern parsing failed\n");
    fclose(in);
    fclose(out);
    return false;
  }

  writeHeader(out);
  writeStyles(out);
  writePatterns(out);
  writeFooter(out);

  FreeGroups(&groups);
  FreeStyles(&styles);
  fclose(in);
  fclose(out);
  return true;
}

void writeHeader(FILE* f) {
  fprintf(f, "// This file is automatically generated, do not modify\n"
    "// Use ../misc/patternconv to generate\n"
    "\n"
    "/*\n"
    " * jmlib-js - Portable JuggleMaster Library (JavaScript Version)\n"
    " * Version 1.0\n"
    " * (C) Per Johan Groland 2006\n"
    " *\n"
    " * Based on JMLib 2.0, (C) Per Johan Groland and Gary Briggs\n"
    " *\n"
    " * Based on JuggleMaster Version 1.60\n"
    " * Copyright (c) 1995-1996 Ken Matsuoka\n"
    " *\n"
    " * You may redistribute and/or modify JMLib_js under the terms of the\n"
    " * Modified BSD License as published in various places online or in the\n"
    " * COPYING.jmlib file in the package you downloaded.\n"
    " *\n"
    " * This program is distributed in the hope that it will be useful, but\n"
    " * WITHOUT  ANY  WARRANTY;  without   even  the  implied  warranty  of\n"
    " * MERCHANTABILITY or  FITNESS FOR A PARTICULAR PURPOSE.   See the\n"
    " * Modified BSD License for more details.\n"
    " */\n"
    "\n");
}

void writeStyles(FILE* f) {
  fprintf(f, "// BEGIN Style data\n");
  fprintf(f, "var styles = [];\n");

  current_style = FirstStyle(&styles);

  while (current_style) {
    int i;

    fprintf(f, "styles[\"%s\"] = new Array(%d, [", 
               Style_GetName(current_style),
               Style_GetLength(current_style)/4);

    for (i = 0; i < (int)Style_GetLength(current_style); i++) {
        if (i == 0) fprintf(f, "%d", Style_GetData(current_style)[i]);
        else        fprintf(f, "%s%d", ", ", Style_GetData(current_style)[i]);
    }
    current_style = NextStyle(current_style);
    fprintf(f, "]);\n");
  }

  fprintf(f, "// END Style data\n\n");
}

void writePatterns(FILE* f) {
  int groupNo = 0;
  int pattNo = 0;
  int pattStart;

  fprintf(f, "// BEGIN Pattern and Group data\n");
  fprintf(f, "var patterns = [];\n");
  fprintf(f, "var groups = [];\n");
  current_group = FirstGroup(&groups);

  while(current_group) {
    current_pattern = Group_GetPatterns(current_group);
    pattStart = pattNo;
		
    while(current_pattern) {
      bool valid = JMSiteValidator::validateSite((JML_CHAR*)Patt_GetData(current_pattern));
      int ballCount = JMSiteValidator::getBallCount();

      // write current pattern
      fprintf(f, "patterns[%d] = new Array(\"%s\", \"%s\", \"%s\", %1.2f, %1.2f, \"%s\");\n",
              pattNo,
              Patt_GetName(current_pattern),
              Patt_GetData(current_pattern),
              Patt_GetStyle(current_pattern),
              Patt_GetHR(current_pattern),
              Patt_GetDR(current_pattern),
              Patt_GetAuthor(current_pattern));

      current_pattern = NextPatt(current_pattern);
      pattNo++;
    }

    // write current group
    fprintf(f, "groups[%d] = new Array(\"%s\", %d, %d);\n",
            groupNo,
            Group_GetName(current_group),
            pattStart,
            pattNo-1);

    current_group = NextGroup(current_group);
    groupNo++;
  }

  fprintf(f, "// END Pattern and Group data\n");
}

void writeFooter(FILE* f) {

}

